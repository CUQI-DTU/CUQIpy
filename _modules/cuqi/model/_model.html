
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>cuqi.model._model &#8212; cuqipy  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=321493ab" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-dropdown.css?v=995e94df" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-bootstrap.min.css?v=21c0b90a" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../_static/doctools.js?v=fd6eb6e6"></script>
    <script src="../../../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/cuqi/model/_model';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="https://github.com/CUQI-DTU/CUQIpy/raw/main/logo.png" class="logo__image only-light" alt="cuqipy  documentation - Home"/>
    <img src="https://github.com/CUQI-DTU/CUQIpy/raw/main/logo.png" class="logo__image only-dark pst-js-only" alt="cuqipy  documentation - Home"/>
  
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../user/index.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../api/index.html">
    API reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../dev/index.html">
    Contributor's Guide
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../user/index.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../api/index.html">
    API reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../dev/index.html">
    Contributor's Guide
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">cuqi.model._model</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for cuqi.model._model</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csc_matrix</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">hstack</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">solve</span>
<span class="kn">from</span> <span class="nn">cuqi.samples</span> <span class="kn">import</span> <span class="n">Samples</span>
<span class="kn">from</span> <span class="nn">cuqi.array</span> <span class="kn">import</span> <span class="n">CUQIarray</span>
<span class="kn">from</span> <span class="nn">cuqi.geometry</span> <span class="kn">import</span> <span class="n">Geometry</span><span class="p">,</span> <span class="n">_DefaultGeometry1D</span><span class="p">,</span> <span class="n">_DefaultGeometry2D</span><span class="p">,</span>\
    <span class="n">_get_identity_geometries</span>
<span class="kn">import</span> <span class="nn">cuqi</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">cuqi.utilities</span> <span class="kn">import</span> <span class="n">force_ndarray</span>

<div class="viewcode-block" id="Model">
<a class="viewcode-back" href="../../../api/_autosummary/cuqi.model/cuqi.model.Model.html#cuqi.model.Model">[docs]</a>
<span class="k">class</span> <span class="nc">Model</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generic model defined by a forward operator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    forward : callable function</span>
<span class="sd">        Forward operator of the model. It takes one or more inputs and returns the model output.</span>

<span class="sd">    range_geometry : integer, a 1D or 2D tuple of integers, cuqi.geometry.Geometry </span>
<span class="sd">        If integer or 1D tuple of integers is given, a cuqi.geometry._DefaultGeometry1D is created with dimension of the integer.</span>
<span class="sd">        If 2D tuple of integers is given, a cuqi.geometry._DefaultGeometry2D is created with dimensions of the tuple.</span>
<span class="sd">        If cuqi.geometry.Geometry object is given, it is used as the range geometry of the model.</span>

<span class="sd">    domain_geometry : integer, a 1D or 2D tuple of integers, cuqi.geometry.Geometry or a tuple with items of any of the listed types</span>
<span class="sd">        If integer or 1D tuple of integers is given, a cuqi.geometry._DefaultGeometry1D is created with dimension of the integer.</span>
<span class="sd">        If 2D tuple of integers is given (and the forward model has one input only), a cuqi.geometry._DefaultGeometry2D is created with dimensions of the tuple.</span>
<span class="sd">        If cuqi.geometry.Geometry is given, it is used as the domain geometry.</span>
<span class="sd">        If tuple of the above types is given, a cuqi.geometry._ProductGeometry is created based on the tuple entries. This is used for models with multiple inputs where each entry in the tuple represents the geometry of each input.</span>

<span class="sd">    gradient : callable function, a tuple of callable functions or None, optional</span>
<span class="sd">        The direction-Jacobian product of the forward model Jacobian with respect to the model input, evaluated at the model input. For example, if the forward model inputs are `x` and `y`, the gradient callable signature should be (`direction`, `x`, `y`), in that order, where `direction` is the direction by which the Jacobian matrix is multiplied and `x` and `y` are the parameters at which the Jacobian is computed.</span>

<span class="sd">        If the gradient function is a single callable function, it returns a 1D ndarray if the model has only one input. If the model has multiple inputs, this gradient function should return a tuple of 1D ndarrays, each representing the gradient with respect to each input.</span>

<span class="sd">        If the gradient function is a tuple of callable functions, each callable function should return a 1D ndarray representing the gradient with respect to each input. The order of the callable functions in the tuple should match the order of the model inputs.</span>

<span class="sd">    jacobian : callable function, a tuple of callable functions or None, optional</span>
<span class="sd">        The Jacobian of the forward model with respect to the forward model input, evaluated at the model input. For example, if the forward model inputs are `x` and `y`, the jacobian signature should be (`x`, `y`), in that order, where `x` and `y` are the parameters at which the Jacobian is computed.</span>

<span class="sd">        If the Jacobian function is a single callable function, it should return a 2D ndarray of shape (range_dim, domain_dim) if the model has only one input. If the model has multiple inputs, this Jacobian function should return a tuple of 2D ndarrays, each representing the Jacobian with respect to each input. </span>
<span class="sd">        </span>
<span class="sd">        If the Jacobian function is a tuple of callable functions, each callable function should return a 2D ndarray representing the Jacobian with respect to each input. The order of the callable functions in the tuple should match the order of the model inputs.</span>
<span class="sd">    </span>
<span class="sd">        The Jacobian function is used to specify the gradient function by computing the vector-Jacobian product (VJP), here we refer to the vector in the VJP as the `direction` since it is the direction at which the gradient is computed. Either the gradient or the Jacobian can be specified, but not both.</span>


<span class="sd">    :ivar range_geometry: The geometry representing the range.</span>
<span class="sd">    :ivar domain_geometry: The geometry representing the domain.</span>

<span class="sd">    Example 1</span>
<span class="sd">    ----------</span>

<span class="sd">    Consider a forward model :math:`F: \mathbb{R}^2 \\rightarrow \mathbb{R}` defined by the following forward operator:</span>

<span class="sd">    .. math::</span>

<span class="sd">        F(x) = 10x_2 - 10x_1^3 + 5x_1^2 + 6x_1</span>

<span class="sd">    The jacobian matrix of the forward operator is given by:</span>

<span class="sd">    .. math::</span>

<span class="sd">        J_F(x) = \\begin{bmatrix} -30x_1^2 + 10x_1 + 6 &amp; 10 \\end{bmatrix}</span>

<span class="sd">    The forward model can be defined as follows:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import numpy as np</span>
<span class="sd">        from cuqi.model import Model</span>

<span class="sd">        def forward(x):</span>
<span class="sd">            return 10*x[1] - 10*x[0]**3 + 5*x[0]**2 + 6*x[0]</span>

<span class="sd">        def jacobian(x): # Can use &quot;x&quot; or &quot;wrt&quot; as the input argument name</span>
<span class="sd">            return np.array([[-30*x[0]**2 + 10*x[0] + 6, 10]])</span>

<span class="sd">        model = Model(forward, range_geometry=1, domain_geometry=2, jacobian=jacobian)</span>

<span class="sd">        print(model(np.array([1, 1])))</span>
<span class="sd">        print(model.gradient(np.array([1]), np.array([1, 1])))</span>

<span class="sd">    Alternatively, the gradient information in the forward model can be defined by direction-Jacobian product using the gradient keyword argument.</span>

<span class="sd">    This may be more efficient if forming the Jacobian matrix is expensive.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import numpy as np</span>
<span class="sd">        from cuqi.model import Model</span>

<span class="sd">        def forward(x):</span>
<span class="sd">            return 10*x[1] - 10*x[0]**3 + 5*x[0]**2 + 6*x[0]</span>

<span class="sd">        def gradient(direction, x):</span>
<span class="sd">            # Direction-Jacobian product direction@jacobian(x)</span>
<span class="sd">            return direction@np.array([[-30*x[0]**2 + 10*x[0] + 6, 10]])</span>

<span class="sd">        model = Model(forward, range_geometry=1, domain_geometry=2, gradient=gradient)</span>

<span class="sd">        print(model(np.array([1, 1])))</span>
<span class="sd">        print(model.gradient(np.array([1]), np.array([1, 1])))</span>

<span class="sd">    Example 2</span>
<span class="sd">    ----------</span>
<span class="sd">    Alternatively, the example above can be defined as a model with multiple inputs: :math:`x` and :math:`y`:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import numpy as np</span>
<span class="sd">        from cuqi.model import Model</span>
<span class="sd">        from cuqi.geometry import Discrete</span>
<span class="sd">    </span>
<span class="sd">        def forward(x, y):</span>
<span class="sd">            return 10 * y - 10 * x**3 + 5 * x**2 + 6 * x</span>
<span class="sd">    </span>
<span class="sd">        def jacobian(x, y):</span>
<span class="sd">            return (np.array([[-30 * x**2 + 10 * x + 6]]), np.array([[10]]))</span>
<span class="sd">    </span>
<span class="sd">        model = Model(</span>
<span class="sd">            forward,</span>
<span class="sd">            range_geometry=1,</span>
<span class="sd">            domain_geometry=(Discrete(1), Discrete(1)),</span>
<span class="sd">            jacobian=jacobian,</span>
<span class="sd">        )</span>
<span class="sd">    </span>
<span class="sd">        print(model(1, 1))</span>
<span class="sd">        print(model.gradient(np.array([1]), 1, 1))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_supports_partial_eval</span> <span class="o">=</span> <span class="kc">True</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Flag indicating that partial evaluation of Model objects is supported, i.e., calling the model object with only some of the inputs specified returns a model that can be called with the remaining inputs.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Model.__init__">
<a class="viewcode-back" href="../../../api/_autosummary/cuqi.model/cuqi.model.Model.__init__.html#cuqi.model.Model.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="n">range_geometry</span><span class="p">,</span> <span class="n">domain_geometry</span><span class="p">,</span> <span class="n">gradient</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">jacobian</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># Check if input is callable</span>
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">forward</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Forward needs to be callable function.&quot;</span><span class="p">)</span>

        <span class="c1"># Store forward func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_forward_func</span> <span class="o">=</span> <span class="n">forward</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stored_non_default_args</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Store range_geometry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">range_geometry</span> <span class="o">=</span> <span class="n">range_geometry</span>

        <span class="c1"># Store domain_geometry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span> <span class="o">=</span> <span class="n">domain_geometry</span>

        <span class="c1"># Additional checks for the forward operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_domain_geometry_consistent_with_forward</span><span class="p">()</span>

        <span class="c1"># Check if only one of gradient and jacobian is given</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">gradient</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">jacobian</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only one of gradient and jacobian should be specified&quot;</span><span class="p">)</span>

        <span class="c1"># Check correct gradient form (check type, signature, etc.)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_correct_gradient_jacobian_form</span><span class="p">(</span><span class="n">gradient</span><span class="p">,</span> <span class="s2">&quot;gradient&quot;</span><span class="p">)</span>

        <span class="c1"># Check correct jacobian form (check type, signature, etc.)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_correct_gradient_jacobian_form</span><span class="p">(</span><span class="n">jacobian</span><span class="p">,</span> <span class="s2">&quot;jacobian&quot;</span><span class="p">)</span>

        <span class="c1"># If jacobian is provided, use it to specify gradient function</span>
        <span class="c1"># (vector-Jacobian product)</span>
        <span class="k">if</span> <span class="n">jacobian</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gradient</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_jacobian_to_specify_gradient</span><span class="p">(</span><span class="n">jacobian</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_gradient_func</span> <span class="o">=</span> <span class="n">gradient</span>

        <span class="c1"># Set gradient output stacked flag to False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gradient_output_stacked</span> <span class="o">=</span> <span class="kc">False</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_non_default_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stored_non_default_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Store non_default_args of the forward operator for faster caching</span>
            <span class="c1"># when checking for those arguments.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stored_non_default_args</span> <span class="o">=</span>\
                <span class="n">cuqi</span><span class="o">.</span><span class="n">utilities</span><span class="o">.</span><span class="n">get_non_default_args</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_forward_func</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stored_non_default_args</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">number_of_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The number of inputs of the model. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_non_default_args</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">range_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The geometry representing the range of the model. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_range_geometry</span>

    <span class="nd">@range_geometry</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">range_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Update the range geometry of the model. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_range_geometry</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_range_geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_default_geometry</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_range_geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_default_geometry</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;The parameter &#39;range_geometry&#39; is not specified by the user and it cannot be inferred from the attribute &#39;forward&#39;.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot; The allowed types for &#39;range_geometry&#39; are: &#39;cuqi.geometry.Geometry&#39;, int, 1D tuple of int, or 2D tuple of int.&quot;</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">domain_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The geometry representing the domain of the model. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_domain_geometry</span>

    <span class="nd">@domain_geometry</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">domain_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Update the domain geometry of the model. &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_domain_geometry</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_domain_geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_default_geometry</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_inputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_domain_geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_default_geometry</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_inputs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">geometries</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_default_geometry</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_domain_geometry</span> <span class="o">=</span> <span class="n">cuqi</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_ProductGeometry</span><span class="p">(</span><span class="o">*</span><span class="n">geometries</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;The parameter &#39;domain_geometry&#39; is not specified by the user and it cannot be inferred from the attribute &#39;forward&#39;.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;For forward model with 1 input, the allowed types for &#39;domain_geometry&#39; are: &#39;cuqi.geometry.Geometry&#39;, int, 1D tuple of int, or 2D tuple of int. For forward model with multiple inputs, the &#39;domain_geometry&#39; should be a tuple with items of any of the above types.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_create_default_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Private function that creates default geometries for the model.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_DefaultGeometry1D</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_DefaultGeometry2D</span><span class="p">(</span><span class="n">im_shape</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Default geometry creation can be specified by an integer or a 2D tuple of integers.&quot;</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">domain_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The dimension of the domain</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span><span class="o">.</span><span class="n">par_dim</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">range_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The dimension of the range</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_geometry</span><span class="o">.</span><span class="n">par_dim</span>

    <span class="k">def</span> <span class="nf">_check_domain_geometry_consistent_with_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Private function that checks if the domain geometry of the model is</span>
<span class="sd">        consistent with the forward operator.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span><span class="p">,</span> <span class="n">cuqi</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_ProductGeometry</span>
            <span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_inputs</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The forward operator input is specified by more than one argument. This is only supported for domain geometry of type tuple with items of type: cuqi.geometry.Geometry object, int, or 2D tuple of int.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_correct_gradient_jacobian_form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">func_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Private function that checks if the gradient/jacobian parameter is</span>
<span class="sd">        in the correct form. That is, check if the gradient/jacobian has the</span>
<span class="sd">        correct type, signature, etc.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># gradient/jacobian should be callable (for single input and multiple input case)</span>
        <span class="c1"># or a tuple of callables (for multiple inputs case)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="c1"># tuple length should be same as the number of inputs</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_inputs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The &quot;</span>
                    <span class="o">+</span> <span class="n">func_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; tuple length should be </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_inputs</span><span class="si">}</span><span class="s2"> for model with inputs </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_non_default_args</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="c1"># tuple items should be callables or None</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">callable</span><span class="p">(</span><span class="n">func_i</span><span class="p">)</span> <span class="ow">or</span> <span class="n">func_i</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">func_i</span> <span class="ow">in</span> <span class="n">func</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="n">func_type</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
                    <span class="o">+</span> <span class="s2">&quot; tuple should contain callable functions or None.&quot;</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="c1"># temporarily convert gradient/jacobian to tuple for checking only</span>
            <span class="n">func</span> <span class="o">=</span> <span class="p">(</span><span class="n">func</span><span class="p">,)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Gradient needs to be callable function or tuple of callable functions.&quot;</span>
            <span class="p">)</span>

        <span class="n">expected_func_non_default_args</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_non_default_args</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_original_non_default_args&quot;</span><span class="p">)</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_non_default_args</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">func_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;gradient&quot;</span><span class="p">:</span>
            <span class="c1"># prepend &#39;direction&#39; to the expected gradient non default args</span>
            <span class="n">expected_func_non_default_args</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;direction&quot;</span>
            <span class="p">]</span> <span class="o">+</span> <span class="n">expected_func_non_default_args</span>

        <span class="k">for</span> <span class="n">func_i</span> <span class="ow">in</span> <span class="n">func</span><span class="p">:</span>
            <span class="c1"># make sure the signature of the gradient/jacobian function is correct</span>
            <span class="c1"># that is, the same as the expected_func_non_default_args</span>
            <span class="k">if</span> <span class="n">func_i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">func_non_default_args</span> <span class="o">=</span> <span class="n">cuqi</span><span class="o">.</span><span class="n">utilities</span><span class="o">.</span><span class="n">get_non_default_args</span><span class="p">(</span><span class="n">func_i</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">func_non_default_args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">(</span><span class="n">expected_func_non_default_args</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="n">func_type</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
                        <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; function signature should be </span><span class="si">{</span><span class="n">expected_func_non_default_args</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_use_jacobian_to_specify_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jacobian</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Private function that uses the jacobian function to specify the</span>
<span class="sd">        gradient function.&quot;&quot;&quot;</span>
        <span class="c1"># if jacobian is a single function and model has multiple inputs</span>
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">jacobian</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_inputs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">gradient</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_gradient_lambda_function_from_jacobian_with_correct_signature</span><span class="p">(</span>
                <span class="n">jacobian</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;one_callable_multiple_inputs&#39;</span>
            <span class="p">)</span>
        <span class="c1"># Elif jacobian is a single function and model has only one input</span>
        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">jacobian</span><span class="p">):</span>
            <span class="n">gradient</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_gradient_lambda_function_from_jacobian_with_correct_signature</span><span class="p">(</span>
                <span class="n">jacobian</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;one_callable_one_input&#39;</span>
            <span class="p">)</span>
        <span class="c1"># Else, jacobian is a tuple of jacobian functions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gradient</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">jac</span> <span class="ow">in</span> <span class="n">jacobian</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">jac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">gradient</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_create_gradient_lambda_function_from_jacobian_with_correct_signature</span><span class="p">(</span>
                            <span class="n">jac</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;tuple_of_callables&#39;</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gradient</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">gradient</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gradient</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="n">gradient</span>

    <span class="k">def</span> <span class="nf">_create_gradient_lambda_function_from_jacobian_with_correct_signature</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">jacobian</span><span class="p">,</span> <span class="n">form</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Private function that creates gradient lambda function from the</span>
<span class="sd">        jacobian function, with the correct signature (based on the model</span>
<span class="sd">        non_default_args).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create the string representation of the lambda function</span>
        <span class="c1"># for different forms of jacobian</span>
        <span class="k">if</span> <span class="n">form</span><span class="o">==</span><span class="s1">&#39;one_callable_multiple_inputs&#39;</span><span class="p">:</span>
            <span class="n">grad_fun_str</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;lambda direction, &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_non_default_args</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;, jacobian: tuple([direction@jacobian(&quot;</span>
                <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_non_default_args</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;)[i] for i in range(&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_inputs</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;)])&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">form</span><span class="o">==</span><span class="s1">&#39;tuple_of_callables&#39;</span> <span class="ow">or</span> <span class="n">form</span><span class="o">==</span><span class="s1">&#39;one_callable_one_input&#39;</span><span class="p">:</span>
            <span class="n">grad_fun_str</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;lambda direction, &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_non_default_args</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;, jacobian: direction@jacobian(&quot;</span>
                <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_non_default_args</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;form should be either &#39;one_callable&#39; or &#39;tuple_of_callables&#39;.&quot;</span><span class="p">)</span>

        <span class="c1"># create the lambda function from the string</span>
        <span class="n">grad_func</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">grad_fun_str</span><span class="p">)</span>

        <span class="c1"># create partial function from the lambda function with jacobian as a</span>
        <span class="c1"># fixed argument</span>
        <span class="n">grad_func</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">grad_func</span><span class="p">,</span> <span class="n">jacobian</span><span class="o">=</span><span class="n">jacobian</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grad_func</span>

    <span class="k">def</span> <span class="nf">_2fun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_par</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Converts `kwargs` to function values (if needed) using the geometry. For example, `kwargs` can be the model input which need to be converted to function value before being passed to :class:`~cuqi.model.Model` operators (e.g. _forward_func, _adjoint_func, _gradient_func).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geometry : cuqi.geometry.Geometry</span>
<span class="sd">            The geometry representing the values in `kwargs`.</span>

<span class="sd">        is_par : bool or a tuple of bools</span>
<span class="sd">            If `is_par` is True, the values in `kwargs` are assumed to be parameters.</span>
<span class="sd">            If `is_par` is False, the values in `kwargs` are assumed to be function values.</span>
<span class="sd">            If `is_par` is a tuple of bools, the values in `kwargs` are assumed to be parameters or function values based on the corresponding boolean value in the tuple.</span>
<span class="sd">        </span>
<span class="sd">        **kwargs : keyword arguments to be converted to function values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict of the converted values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check kwargs and geometry are consistent and set up geometries list and</span>
        <span class="c1"># is_par tuple</span>
        <span class="n">geometries</span><span class="p">,</span> <span class="n">is_par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_helper_pre_conversion_checks_and_processing</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">is_par</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Convert to function values</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="c1"># Use CUQIarray funvals if geometry is consistent</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">CUQIarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">geometry</span> <span class="o">==</span> <span class="n">geometries</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">funvals</span>
            <span class="c1"># Else, if we still need to convert to function value (is_par[i] is True)</span>
            <span class="c1"># we use the geometry par2fun method</span>
            <span class="k">elif</span> <span class="n">is_par</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">geometries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">par2fun</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># No need to convert</span>
                <span class="k">pass</span>

        <span class="k">return</span> <span class="n">kwargs</span>

    <span class="k">def</span> <span class="nf">_helper_pre_conversion_checks_and_processing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_par</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Helper function that checks if kwargs and geometry are consistent</span>
<span class="sd">        and sets up geometries list and is_par tuple.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If len of kwargs is larger than 1, the geometry needs to be of type</span>
        <span class="c1"># _ProductGeometry</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">cuqi</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_ProductGeometry</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The input is specified by more than one argument. This is only &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;supported for domain geometry of type &quot;</span>
                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cuqi</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_ProductGeometry</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># If is_par is bool, make it a tuple of bools of the same length as</span>
        <span class="c1"># kwargs</span>
        <span class="n">is_par</span> <span class="o">=</span> <span class="p">(</span><span class="n">is_par</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">is_par</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">else</span> <span class="n">is_par</span>

        <span class="c1"># Set up geometries list</span>
        <span class="n">geometries</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">geometry</span><span class="o">.</span><span class="n">geometries</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">cuqi</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_ProductGeometry</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">[</span><span class="n">geometry</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">geometries</span><span class="p">,</span> <span class="n">is_par</span>

    <span class="k">def</span> <span class="nf">_2par</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">to_CUQIarray</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">is_par</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>    
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Converts `kwargs` to parameters using the geometry. For example, `kwargs` can be the output of :class:`~cuqi.model.Model` operators (e.g. _forward_func, _adjoint_func, _gradient_func) which need to be converted to parameters before being returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geometry : cuqi.geometry.Geometry</span>
<span class="sd">            The geometry representing the values in `kwargs`.</span>

<span class="sd">        to_CUQIarray : bool or a tuple of bools</span>
<span class="sd">            If `to_CUQIarray` is True, the values in `kwargs` will be wrapped in `CUQIarray`.</span>
<span class="sd">            If `to_CUQIarray` is False, the values in `kwargs` will not be wrapped in `CUQIarray`.</span>
<span class="sd">            If `to_CUQIarray` is a tuple of bools, the values in `kwargs` will be wrapped in `CUQIarray` or not based on the corresponding boolean value in the tuple.</span>
<span class="sd">        </span>
<span class="sd">        is_par : bool or a tuple of bools</span>
<span class="sd">            If `is_par` is True, the values in `kwargs` are assumed to be parameters.</span>
<span class="sd">            If `is_par` is False, the values in `kwargs` are assumed to be function values.</span>
<span class="sd">            If `is_par` is a tuple of bools, the values in `kwargs` are assumed to be parameters or function values based on the corresponding boolean value in the tuple.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict of the converted values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check kwargs and geometry are consistent and set up geometries list and</span>
        <span class="c1"># is_par tuple</span>
        <span class="n">geometries</span><span class="p">,</span> <span class="n">is_par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_helper_pre_conversion_checks_and_processing</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">is_par</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># if to_CUQIarray is bool, make it a tuple of bools of the same length</span>
        <span class="c1"># as kwargs</span>
        <span class="n">to_CUQIarray</span> <span class="o">=</span> <span class="p">(</span><span class="n">to_CUQIarray</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to_CUQIarray</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">else</span> <span class="n">to_CUQIarray</span>

        <span class="c1"># Convert to parameters</span>
        <span class="k">for</span> <span class="n">i</span> <span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="c1"># Use CUQIarray parameters if geometry is consistent</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">CUQIarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">geometry</span> <span class="o">==</span> <span class="n">geometries</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">parameters</span>
            <span class="c1"># Else, if we still need to convert to parameter value (is_par[i] is False)</span>
            <span class="c1"># we use the geometry fun2par method</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_par</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">geometries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">fun2par</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># No need to convert</span>
                <span class="k">pass</span>

            <span class="c1"># Wrap the value v in CUQIarray if requested</span>
            <span class="k">if</span> <span class="n">to_CUQIarray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">CUQIarray</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">is_par</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">geometries</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">return</span> <span class="n">kwargs</span>

    <span class="k">def</span> <span class="nf">_apply_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fwd</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">is_par</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Private function that applies the given function `func` to the input `kwargs`. It converts the input to function values (if needed) and converts the output to parameter values. It additionally handles the case of applying the function `func` to cuqi.samples.Samples objects.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func: function handler </span>
<span class="sd">            The function to be applied.</span>

<span class="sd">        fwd : bool</span>
<span class="sd">            Flag indicating the direction of the operator to determine the range and domain geometries of the function.</span>
<span class="sd">            If True the function is a forward operator.</span>
<span class="sd">            If False the function is an adjoint operator.</span>

<span class="sd">        is_par : bool or list of bool</span>
<span class="sd">            If True, the inputs in `kwargs` are assumed to be parameters.</span>
<span class="sd">            If False, the input in `kwargs` are assumed to be function values.</span>
<span class="sd">            If `is_par` is a list of bools, the inputs are assumed to be parameters or function values based on the corresponding boolean value in the list.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray or cuqi.array.CUQIarray or cuqi.samples.Samples object</span>
<span class="sd">            The output of the function.</span>
<span class="sd">        &quot;&quot;&quot;</span> 
        <span class="c1"># Specify the range and domain geometries of the function</span>
        <span class="c1"># If forward operator, range geometry is the model range geometry and</span>
        <span class="c1"># domain geometry is the model domain geometry</span>
        <span class="k">if</span> <span class="n">fwd</span><span class="p">:</span>
            <span class="n">func_range_geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_geometry</span>
            <span class="n">func_domain_geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span>
        <span class="c1"># If adjoint operator, range geometry is the model domain geometry and</span>
        <span class="c1"># domain geometry is the model range geometry</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">func_range_geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span>
            <span class="n">func_domain_geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_geometry</span>

        <span class="c1"># If input x is Samples we apply func for each sample</span>
        <span class="c1"># TODO: Check if this can be done all-at-once for computational speed-up</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Samples</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_case_when_model_input_is_samples</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">fwd</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># store if any input x is CUQIarray</span>
        <span class="n">is_CUQIarray</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">CUQIarray</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="c1"># Convert input to function values</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_2fun</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="n">func_domain_geometry</span><span class="p">,</span> <span class="n">is_par</span><span class="o">=</span><span class="n">is_par</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Apply the function</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Return output as parameters</span>
        <span class="c1"># (wrapped in CUQIarray if any input was CUQIarray)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_2par</span><span class="p">(</span>
            <span class="n">geometry</span><span class="o">=</span><span class="n">func_range_geometry</span><span class="p">,</span> <span class="n">to_CUQIarray</span><span class="o">=</span><span class="n">is_CUQIarray</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="s2">&quot;out&quot;</span><span class="p">:</span> <span class="n">out</span><span class="p">}</span>
        <span class="p">)[</span><span class="s2">&quot;out&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_handle_case_when_model_input_is_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fwd</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Private function that calls apply_func for samples in the</span>
<span class="sd">        Samples object(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># All kwargs should be Samples objects</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Samples</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;If applying the function to Samples, all inputs should be Samples.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># All Samples objects should have the same number of samples</span>
        <span class="n">Ns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Ns</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">Ns</span> <span class="o">==</span> <span class="n">Ns</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;If applying the function to Samples, all inputs should have the same number of samples.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Specify the range dimension of the function</span>
        <span class="n">range_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_dim</span> <span class="k">if</span> <span class="n">fwd</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain_dim</span>

        <span class="c1"># Create empty array to store the output</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">range_dim</span><span class="p">,</span> <span class="n">Ns</span><span class="p">))</span>

        <span class="c1"># Recursively apply func to each sample</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ns</span><span class="p">):</span>
            <span class="n">kwargs_i</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">CUQIarray</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">is_par</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">is_par</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="n">out</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_func</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">fwd</span><span class="o">=</span><span class="n">fwd</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_i</span><span class="p">)</span>
        <span class="c1"># Specify the range geometries of the function</span>
        <span class="n">func_range_geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_geometry</span> <span class="k">if</span> <span class="n">fwd</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span>
        <span class="k">return</span> <span class="n">Samples</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">func_range_geometry</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_parse_args_add_to_kwargs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">is_par</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">non_default_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">map_name</span><span class="o">=</span><span class="s2">&quot;model&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Private function that parses the input arguments and adds them as</span>
<span class="sd">        keyword arguments matching (the order of) the non default arguments of</span>
<span class="sd">        the forward function or other specified non_default_args list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If non_default_args is not specified, use the non_default_args of the</span>
        <span class="c1"># model</span>
        <span class="k">if</span> <span class="n">non_default_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">non_default_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_non_default_args</span>

        <span class="c1"># Either args or kwargs can be provided but not both</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The &quot;</span>
                <span class="o">+</span> <span class="n">map_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="o">+</span> <span class="s2">&quot; input is specified both as positional and keyword arguments. This is not supported.&quot;</span>
            <span class="p">)</span>

        <span class="n">len_input</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># If partial evaluation, make sure input is not of type Samples</span>
        <span class="k">if</span> <span class="n">len_input</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_default_args</span><span class="p">):</span>
            <span class="c1"># If the argument is a Sample object, splitting or partial</span>
            <span class="c1"># evaluation of the model is not supported</span>
            <span class="n">temp_args</span> <span class="o">=</span> <span class="n">args</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Samples</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">temp_args</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s2">&quot;When using Samples objects as input, the&quot;</span>
                                <span class="o">+</span><span class="s2">&quot; user should provide a Samples object for&quot;</span>
                                <span class="o">+</span><span class="sa">f</span><span class="s2">&quot; each non_default_args </span><span class="si">{</span><span class="n">non_default_args</span><span class="si">}</span><span class="s2">&quot;</span>
                                <span class="o">+</span><span class="s2">&quot; of the model. That is, partial evaluation&quot;</span>
                                <span class="o">+</span><span class="s2">&quot; or splitting is not supported for input&quot;</span>
                                <span class="o">+</span><span class="s2">&quot; of type Samples.&quot;</span><span class="p">))</span>

        <span class="c1"># If args are given, add them to kwargs</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

            <span class="c1"># Check if the input is for multiple input case and is stacked,</span>
            <span class="c1"># then split it</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_default_args</span><span class="p">):</span>
                <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_in_case_of_stacked_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">is_par</span><span class="o">=</span><span class="n">is_par</span><span class="p">)</span>

            <span class="c1"># Add args to kwargs following the order of non_default_args</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">non_default_args</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="o">=</span> <span class="n">arg</span>
    
        <span class="c1"># Check kwargs matches non_default_args</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">&lt;=</span> <span class="nb">set</span><span class="p">(</span><span class="n">non_default_args</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">map_name</span> <span class="o">==</span> <span class="s2">&quot;gradient&quot;</span><span class="p">:</span>
                <span class="n">error_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;The gradient input is specified by a direction and keywords arguments </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2"> that does not match the non_default_args of the model </span><span class="si">{</span><span class="n">non_default_args</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">error_msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;The &quot;</span>
                    <span class="o">+</span> <span class="n">map_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; input is specified by keywords arguments </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2"> that does not match the non_default_args of the &quot;</span>
                    <span class="o">+</span> <span class="n">map_name</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">non_default_args</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>

        <span class="c1"># Make sure order of kwargs is the same as non_default_args</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">non_default_args</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">kwargs</span>

    <span class="k">def</span> <span class="nf">_split_in_case_of_stacked_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">is_par</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Private function that checks if the input args is a stacked</span>
<span class="sd">        CUQIarray or numpy array and splits it into multiple arguments based on</span>
<span class="sd">        the domain geometry of the model. Otherwise, it returns the input args</span>
<span class="sd">        unchanged.&quot;&quot;&quot;</span>

        <span class="c1"># Check conditions for splitting and split if all conditions are met</span>
        <span class="n">is_CUQIarray</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">CUQIarray</span><span class="p">)</span>
        <span class="n">is_numpy_array</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">is_CUQIarray</span> <span class="ow">or</span> <span class="n">is_numpy_array</span><span class="p">)</span> <span class="ow">and</span>
           <span class="n">is_par</span> <span class="ow">and</span>
           <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
           <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain_dim</span><span class="p">,)</span> <span class="ow">and</span>
           <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span><span class="p">,</span> <span class="n">cuqi</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_ProductGeometry</span><span class="p">)):</span>
            <span class="c1"># Split the stacked input</span>
            <span class="n">split_args</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span><span class="o">.</span><span class="n">stacked_par_split_indices</span><span class="p">)</span>
            <span class="c1"># Convert split args to CUQIarray if input is CUQIarray</span>
            <span class="k">if</span> <span class="n">is_CUQIarray</span><span class="p">:</span>
                <span class="n">split_args</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">CUQIarray</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">is_par</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span><span class="o">.</span><span class="n">geometries</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">split_args</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="k">return</span> <span class="n">split_args</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="Model.forward">
<a class="viewcode-back" href="../../../api/_autosummary/cuqi.model/cuqi.model.Model.forward.html#cuqi.model.Model.forward">[docs]</a>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">is_par</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Forward function of the model.</span>

<span class="sd">        Forward converts the input to function values (if needed) using the domain geometry of the model. Then it applies the forward operator to the function values and converts the output to parameters using the range geometry of the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args : ndarrays or cuqi.array.CUQIarray objects or cuqi.samples.Samples objects</span>
<span class="sd">            Positional arguments for the forward operator. The forward operator input can be specified as either positional arguments or keyword arguments but not both.</span>

<span class="sd">            If the input is specified as positional arguments, the order of the arguments should match the non_default_args of the model.</span>

<span class="sd">        is_par : bool or a tuple of bools</span>
<span class="sd">            If True, the inputs in `args` or `kwargs` are assumed to be parameters.</span>
<span class="sd">            If False, the inputs in `args` or `kwargs` are assumed to be function values.</span>
<span class="sd">            If `is_par` is a tuple of bools, the inputs are assumed to be parameters or function values based on the corresponding boolean value in the tuple.</span>

<span class="sd">        **kwargs : keyword arguments</span>
<span class="sd">            keyword arguments for the forward operator. The forward operator input can be specified as either positional arguments or keyword arguments but not both.</span>

<span class="sd">            If the input is specified as keyword arguments, the keys should match the non_default_args of the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray or cuqi.array.CUQIarray or cuqi.samples.Samples object</span>
<span class="sd">            The model output. Always returned as parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Add args to kwargs and ensure the order of the arguments matches the</span>
        <span class="c1"># non_default_args of the forward function</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args_add_to_kwargs</span><span class="p">(</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">is_par</span><span class="o">=</span><span class="n">is_par</span><span class="p">,</span> <span class="n">map_name</span><span class="o">=</span><span class="s2">&quot;model&quot;</span>
        <span class="p">)</span>
        <span class="c1"># Extract args from kwargs</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">partial_arguments</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_non_default_args</span><span class="p">)</span>

        <span class="c1"># If input is a distribution, we simply change the parameter name of</span>
        <span class="c1"># model to match the distribution name</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">cuqi</span><span class="o">.</span><span class="n">distribution</span><span class="o">.</span><span class="n">Distribution</span><span class="p">)</span>
               <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">partial_arguments</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Partial evaluation of the model is not supported for distributions.&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_case_when_model_input_is_distributions</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># If input is a random variable, we handle it separately</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">cuqi</span><span class="o">.</span><span class="n">algebra</span><span class="o">.</span><span class="n">RandomVariable</span><span class="p">)</span>
               <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">partial_arguments</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Partial evaluation of the model is not supported for random variables.&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_case_when_model_input_is_random_variables</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># If input is a Node from internal abstract syntax tree, we let the Node handle the operation</span>
        <span class="c1"># We use NotImplemented to indicate that the operation is not supported from the Model class</span>
        <span class="c1"># in case of operations such as &quot;@&quot; that can be interpreted as both __matmul__ and __rmatmul__</span>
        <span class="c1"># the operation may be delegated to the Node class.</span>
        <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">args_i</span><span class="p">,</span> <span class="n">cuqi</span><span class="o">.</span><span class="n">algebra</span><span class="o">.</span><span class="n">Node</span><span class="p">)</span> <span class="k">for</span> <span class="n">args_i</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="c1"># if input is partial, we create a new model with the partial input</span>
        <span class="k">if</span> <span class="n">partial_arguments</span><span class="p">:</span>
            <span class="c1"># Create is_par_partial from the is_par to contain only the relevant parts</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">is_par</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="n">is_par_partial</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">is_par</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_inputs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_non_default_args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">is_par_partial</span> <span class="o">=</span> <span class="n">is_par</span>
            <span class="c1"># Build a partial model with the given kwargs</span>
            <span class="n">partial_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_partial_model</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">is_par_partial</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">partial_model</span>

        <span class="c1"># Else we apply the forward operator</span>
        <span class="c1"># if model has _original_non_default_args, we use it to replace the</span>
        <span class="c1"># kwargs keys so that it matches self._forward_func signature</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_original_non_default_args&#39;</span><span class="p">):</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_original_non_default_args</span><span class="p">,</span> <span class="n">args</span><span class="p">)}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_func</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_forward_func</span><span class="p">,</span>
                                <span class="n">fwd</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">is_par</span><span class="o">=</span><span class="n">is_par</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_correct_distribution_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distributions</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Private function that checks if the dimension of the</span>
<span class="sd">        distributions matches the domain dimension of the model.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">distributions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">distributions</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain_dim</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">distributions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span><span class="p">,</span> <span class="n">cuqi</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_ProductGeometry</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">(</span>
                <span class="n">d</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span><span class="o">.</span><span class="n">par_dim_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">distributions</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_build_partial_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">is_par</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Private function that builds a partial model substituting the given</span>
<span class="sd">        keyword arguments with their values. The created partial model will have</span>
<span class="sd">        as inputs the non-default arguments that are not in the kwargs.&quot;&quot;&quot;</span>

        <span class="c1"># Extract args from kwargs</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="c1"># Define original_non_default_args which represents the complete list of</span>
        <span class="c1"># non-default arguments of the forward function.</span>
        <span class="n">original_non_default_args</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_original_non_default_args</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_original_non_default_args&quot;</span><span class="p">)</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_non_default_args</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_original_non_default_args&quot;</span><span class="p">):</span>
            <span class="c1"># Split the _original_non_default_args into two lists:</span>
            <span class="c1"># 1. reduced_original_non_default_args: the _original_non_default_args</span>
            <span class="c1"># corresponding to the _non_default_args that are not in kwargs</span>
            <span class="c1"># 2. substituted_non_default_args: the _original_non_default_args</span>
            <span class="c1"># corresponding to the _non_default_args that are in kwargs</span>
            <span class="n">reduced_original_non_default_args</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">original_non_default_args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_inputs</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_non_default_args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="p">]</span>
            <span class="n">substituted_non_default_args</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">original_non_default_args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_inputs</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_non_default_args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="p">]</span>
            <span class="c1"># Replace the keys in kwargs with the substituted_non_default_args</span>
            <span class="c1"># so that the kwargs match the signature of the _forward_func</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">substituted_non_default_args</span><span class="p">,</span> <span class="n">args</span><span class="p">)}</span>

        <span class="c1"># Create a partial domain geometry with the geometries corresponding</span>
        <span class="c1"># to the non-default arguments that are not in kwargs (remaining</span>
        <span class="c1"># unspecified inputs)</span>
        <span class="n">partial_domain_geometry</span> <span class="o">=</span> <span class="n">cuqi</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_ProductGeometry</span><span class="p">(</span>
            <span class="o">*</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span><span class="o">.</span><span class="n">geometries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_inputs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">original_non_default_args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">partial_domain_geometry</span><span class="o">.</span><span class="n">geometries</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">partial_domain_geometry</span> <span class="o">=</span> <span class="n">partial_domain_geometry</span><span class="o">.</span><span class="n">geometries</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Create a domain geometry with the geometries corresponding to the</span>
        <span class="c1"># non-default arguments that are specified</span>
        <span class="n">substituted_domain_geometry</span> <span class="o">=</span> <span class="n">cuqi</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_ProductGeometry</span><span class="p">(</span>
            <span class="o">*</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span><span class="o">.</span><span class="n">geometries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_inputs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">original_non_default_args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">substituted_domain_geometry</span><span class="o">.</span><span class="n">geometries</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">substituted_domain_geometry</span> <span class="o">=</span> <span class="n">substituted_domain_geometry</span><span class="o">.</span><span class="n">geometries</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Create new model with partial input</span>
        <span class="c1"># First, we convert the input to function values</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_2fun</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="n">substituted_domain_geometry</span><span class="p">,</span> <span class="n">is_par</span><span class="o">=</span><span class="n">is_par</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Second, we create a partial function for the forward operator</span>
        <span class="n">partial_forward</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_forward_func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Third, if applicable, we create a partial function for the gradient</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gradient_func</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="c1"># If gradient is a tuple, we create a partial function for each</span>
            <span class="c1"># gradient function in the tuple</span>
            <span class="n">partial_gradient</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gradient_func</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gradient_func</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="k">else</span> <span class="kc">None</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_inputs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">original_non_default_args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">partial_gradient</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">partial_gradient</span> <span class="o">=</span> <span class="n">partial_gradient</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gradient_func</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Partial forward model is only supported for gradient/jacobian functions that are tuples of callable functions.&quot;</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">partial_gradient</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Lastly, we create the partial model with the partial forward</span>
        <span class="c1"># operator (we set the gradient function later)</span>
        <span class="n">partial_model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span>
            <span class="n">forward</span><span class="o">=</span><span class="n">partial_forward</span><span class="p">,</span>
            <span class="n">range_geometry</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range_geometry</span><span class="p">,</span>
            <span class="n">domain_geometry</span><span class="o">=</span><span class="n">partial_domain_geometry</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Set the _original_non_default_args (if applicable) and</span>
        <span class="c1"># _stored_non_default_args of the partial model</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_original_non_default_args&quot;</span><span class="p">):</span>
            <span class="n">partial_model</span><span class="o">.</span><span class="n">_original_non_default_args</span> <span class="o">=</span> <span class="n">reduced_original_non_default_args</span>
        <span class="n">partial_model</span><span class="o">.</span><span class="n">_stored_non_default_args</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_non_default_args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_inputs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">original_non_default_args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">]</span>

        <span class="c1"># Set the gradient function of the partial model</span>
        <span class="n">partial_model</span><span class="o">.</span><span class="n">_check_correct_gradient_jacobian_form</span><span class="p">(</span>
            <span class="n">partial_gradient</span><span class="p">,</span> <span class="s2">&quot;gradient&quot;</span>
        <span class="p">)</span>
        <span class="n">partial_model</span><span class="o">.</span><span class="n">_gradient_func</span> <span class="o">=</span> <span class="n">partial_gradient</span>

        <span class="k">return</span> <span class="n">partial_model</span>

    <span class="k">def</span> <span class="nf">_handle_case_when_model_input_is_distributions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Private function that handles the case of the input being a</span>
<span class="sd">        distribution or multiple distributions.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correct_distribution_dimension</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Attempting to match parameter name of Model with given distribution(s), but distribution(s) dimension(s) does not match model input dimension(s).&quot;</span>
            <span class="p">)</span>
        <span class="n">new_model</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Store the original non_default_args of the model</span>
        <span class="n">new_model</span><span class="o">.</span><span class="n">_original_non_default_args</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_original_non_default_args</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_original_non_default_args&quot;</span><span class="p">)</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_non_default_args</span>
        <span class="p">)</span>

        <span class="c1"># Update the non_default_args of the model to match the distribution</span>
        <span class="c1"># names. Defaults to x in the case of only one distribution that has no</span>
        <span class="c1"># name</span>
        <span class="n">new_model</span><span class="o">.</span><span class="n">_stored_non_default_args</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>

        <span class="c1"># If there is a repeated name, raise an error</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">new_model</span><span class="o">.</span><span class="n">_stored_non_default_args</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">new_model</span><span class="o">.</span><span class="n">_stored_non_default_args</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Attempting to match parameter name of Model with given distributions, but distribution names are not unique. Please provide unique names for the distributions.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">new_model</span>

    <span class="k">def</span> <span class="nf">_handle_case_when_model_input_is_random_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Private function that handles the case of the input being a random variable. &quot;&quot;&quot;</span>
        <span class="c1"># If random variable is not a leaf-type node (e.g. internal node) we return NotImplemented</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">tree</span><span class="p">,</span> <span class="n">cuqi</span><span class="o">.</span><span class="n">algebra</span><span class="o">.</span><span class="n">VariableNode</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>        

        <span class="c1"># Extract the random variable distributions and check dimensions consistency with domain geometry</span>
        <span class="n">distributions</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="o">.</span><span class="n">distribution</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correct_distribution_dimension</span><span class="p">(</span><span class="n">distributions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Attempting to match parameter name of Model with given random variable(s), but random variable dimension(s) does not match model input dimension(s).&quot;</span><span class="p">)</span>

        <span class="n">new_model</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Store the original non_default_args of the model</span>
        <span class="n">new_model</span><span class="o">.</span><span class="n">_original_non_default_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_non_default_args</span>

        <span class="c1"># Update the non_default_args of the model to match the random variable</span>
        <span class="c1"># names. Defaults to x in the case of only one random variable that has</span>
        <span class="c1"># no name</span>
        <span class="n">new_model</span><span class="o">.</span><span class="n">_stored_non_default_args</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">distributions</span><span class="p">]</span>

        <span class="c1"># If there is a repeated name, raise an error</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">new_model</span><span class="o">.</span><span class="n">_stored_non_default_args</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">new_model</span><span class="o">.</span><span class="n">_stored_non_default_args</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Attempting to match parameter name of Model with given random variables, but random variables names are not unique. Please provide unique names for the random variables.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">new_model</span>

<div class="viewcode-block" id="Model.gradient">
<a class="viewcode-back" href="../../../api/_autosummary/cuqi.model/cuqi.model.Model.gradient.html#cuqi.model.Model.gradient">[docs]</a>
    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">is_direction_par</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">is_var_par</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gradient of the forward operator (Direction-Jacobian product)</span>

<span class="sd">        The gradient computes the Vector-Jacobian product (VJP) of the forward operator evaluated at the given model input and the given vector (direction).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        direction : ndarray or cuqi.array.CUQIarray</span>
<span class="sd">            The direction at which to compute the gradient.</span>

<span class="sd">        *args : ndarrays or cuqi.array.CUQIarray objects</span>
<span class="sd">            Positional arguments for the values at which to compute the gradient. The gradient operator input can be specified as either positional arguments or keyword arguments but not both.</span>

<span class="sd">            If the input is specified as positional arguments, the order of the arguments should match the non_default_args of the model.</span>

<span class="sd">        is_direction_par : bool</span>
<span class="sd">            If True, `direction` is assumed to be parameters.</span>
<span class="sd">            If False, `direction` is assumed to be function values.</span>

<span class="sd">        is_var_par : bool or a tuple of bools</span>
<span class="sd">            If True, the inputs in `args` or `kwargs` are assumed to be parameters.</span>
<span class="sd">            If False, the inputs in `args` or `kwargs` are assumed to be function values.</span>
<span class="sd">            If `is_var_par` is a tuple of bools, the inputs in `args` or `kwargs` are assumed to be parameters or function values based on the corresponding boolean value in the tuple.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Add args to kwargs and ensure the order of the arguments matches the</span>
        <span class="c1"># non_default_args of the forward function</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args_add_to_kwargs</span><span class="p">(</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">is_par</span><span class="o">=</span><span class="n">is_var_par</span><span class="p">,</span> <span class="n">map_name</span><span class="o">=</span><span class="s2">&quot;gradient&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Obtain the parameters representation of the variables and raise an</span>
        <span class="c1"># error if it cannot be obtained</span>
        <span class="n">error_message</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;For the gradient to be computed, is_var_par needs to be True and the variables in kwargs needs to be parameter value, not function value. Alternatively, the model domain_geometry:&quot;</span>
            <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="o">+</span> <span class="s2">&quot;should have an implementation of the method fun2par&quot;</span>
        <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">kwargs_par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_2par</span><span class="p">(</span>
                <span class="n">geometry</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span><span class="p">,</span>
                <span class="n">is_par</span><span class="o">=</span><span class="n">is_var_par</span><span class="p">,</span>
                <span class="n">to_CUQIarray</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># NotImplementedError will be raised if fun2par of the geometry is not</span>
        <span class="c1"># implemented and ValueError will be raised when imap is not set in</span>
        <span class="c1"># MappedGeometry</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="n">error_message</span>
                <span class="o">+</span> <span class="s2">&quot; ,including an implementation of imap for MappedGeometry&quot;</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">error_message</span><span class="p">)</span>

        <span class="c1"># Check for other errors that may prevent computing the gradient</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_gradient_can_be_computed</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Also obtain the function values representation of the variables</span>
        <span class="n">kwargs_fun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_2fun</span><span class="p">(</span>
            <span class="n">geometry</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span><span class="p">,</span> <span class="n">is_par</span><span class="o">=</span><span class="n">is_var_par</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="c1"># Store if any of the inputs is a CUQIarray</span>
        <span class="n">to_CUQIarray</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">CUQIarray</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">CUQIarray</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">kwargs_fun</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="c1"># Turn to_CUQIarray to a tuple of bools of the same length as kwargs_fun</span>
        <span class="n">to_CUQIarray</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">to_CUQIarray</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs_fun</span><span class="p">))</span>

        <span class="c1"># Convert direction to function value</span>
        <span class="n">direction_fun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_2fun</span><span class="p">(</span>
            <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range_geometry</span><span class="p">,</span> <span class="n">is_par</span><span class="o">=</span><span class="n">is_direction_par</span>
        <span class="p">)</span>

        <span class="c1"># If model has _original_non_default_args, we use it to replace the</span>
        <span class="c1"># kwargs keys so that it matches self._gradient_func signature</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_original_non_default_args&#39;</span><span class="p">):</span>
            <span class="n">args_fun</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs_fun</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="n">kwargs_fun</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_original_non_default_args</span><span class="p">,</span> <span class="n">args_fun</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="c1"># Append the direction to the kwargs_fun as first input</span>
        <span class="n">kwargs_fun_grad_input</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">direction_fun</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_fun</span><span class="p">}</span>

        <span class="c1"># Form 1 of gradient (callable)</span>
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gradient_func</span><span class="p">):</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gradient_func</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs_fun_grad_input</span><span class="p">)</span>
            <span class="n">grad_is_par</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Assume gradient is function value</span>

        <span class="c1"># Form 2 of gradient (tuple of callables)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gradient_func</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">grad_func</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gradient_func</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">grad_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">grad</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grad_func</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs_fun_grad_input</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">grad</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                    <span class="c1"># set the ith item of to_CUQIarray tuple to False</span>
                    <span class="c1"># because the ith gradient is None</span>
                    <span class="n">to_CUQIarray</span> <span class="o">=</span> <span class="n">to_CUQIarray</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="kc">False</span><span class="p">,)</span> <span class="o">+</span> <span class="n">to_CUQIarray</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
            <span class="n">grad_is_par</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Assume gradient is function value</span>

        <span class="n">grad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_chain_rule_to_account_for_domain_geometry_gradient</span><span class="p">(</span>
            <span class="n">kwargs_par</span><span class="p">,</span> <span class="n">grad</span><span class="p">,</span> <span class="n">grad_is_par</span><span class="p">,</span> <span class="n">to_CUQIarray</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grad</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">grad</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gradient_output_stacked</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">(</span>
                        <span class="n">v</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">CUQIarray</span><span class="p">)</span>
                        <span class="k">else</span> <span class="n">force_ndarray</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">flatten</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">grad</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                <span class="p">]</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">grad</span></div>


    <span class="k">def</span> <span class="nf">_check_gradient_can_be_computed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">kwargs_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Private function that checks if the gradient can be computed. By</span>
<span class="sd">        raising an error for the cases where the gradient cannot be computed.&quot;&quot;&quot;</span>

        <span class="c1"># Raise an error if _gradient_func function is not set</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gradient_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Gradient is not implemented for this model.&quot;</span><span class="p">)</span>

        <span class="c1"># Raise an error if either the direction or kwargs are Samples objects</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">Samples</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Samples</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">kwargs_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Gradient is not implemented for input of type Samples.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Raise an error if range_geometry is not in the list returned by</span>
        <span class="c1"># `_get_identity_geometries()`. i.e. The Jacobian of its</span>
        <span class="c1"># par2fun map is not identity.</span>
        <span class="c1"># TODO: Add range geometry gradient to the chain rule</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range_geometry</span><span class="p">)</span> <span class="ow">in</span> <span class="n">_get_identity_geometries</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Gradient is not implemented for model </span><span class="si">{}</span><span class="s2"> with range geometry </span><span class="si">{}</span><span class="s2">. You can use one of the geometries in the list </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">range_geometry</span><span class="p">,</span>
                    <span class="p">[</span><span class="n">i_g</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">i_g</span> <span class="ow">in</span> <span class="n">_get_identity_geometries</span><span class="p">()],</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Raise an error if domain_geometry (or its components in case of</span>
        <span class="c1"># _ProductGeometry) does not have gradient attribute and is not in the</span>
        <span class="c1"># list returned by `_get_identity_geometries()`. i.e. The Jacobian of its</span>
        <span class="c1"># par2fun map is not identity.</span>
        <span class="n">domain_geometries</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span><span class="o">.</span><span class="n">geometries</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span><span class="p">,</span> <span class="n">cuqi</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_ProductGeometry</span>
            <span class="p">)</span>
            <span class="k">else</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">domain_geometry</span> <span class="ow">in</span> <span class="n">domain_geometries</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">domain_geometry</span><span class="p">,</span> <span class="s2">&quot;gradient&quot;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">domain_geometry</span><span class="p">)</span> <span class="ow">in</span> <span class="n">_get_identity_geometries</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Gradient is not implemented for model </span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s2">with domain geometry (or domain geometry component) </span><span class="si">{}</span><span class="s2">. The domain geometries should have gradient method or be from the geometries in the list </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="bp">self</span><span class="p">,</span>
                        <span class="n">domain_geometry</span><span class="p">,</span>
                        <span class="p">[</span><span class="n">i_g</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">i_g</span> <span class="ow">in</span> <span class="n">_get_identity_geometries</span><span class="p">()],</span>
                    <span class="p">)</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_apply_chain_rule_to_account_for_domain_geometry_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                                                  <span class="n">kwargs_par</span><span class="p">,</span>
                                                                  <span class="n">grad</span><span class="p">,</span>
                                                                  <span class="n">grad_is_par</span><span class="p">,</span>
                                                                  <span class="n">to_CUQIarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Private function that applies the chain rule to account for the</span>
<span class="sd">        gradient of the domain geometry. That is, it computes the gradient of</span>
<span class="sd">        the function values with respect to the parameters values.&quot;&quot;&quot;</span>
        <span class="c1"># Create list of domain geometries</span>
        <span class="n">geometries</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span><span class="o">.</span><span class="n">geometries</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span><span class="p">,</span> <span class="n">cuqi</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_ProductGeometry</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># turn grad_is_par to a tuple of bools if it is not already</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grad_is_par</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">grad_is_par</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">grad_is_par</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_inputs</span><span class="p">)</span>

        <span class="c1"># If the domain geometry is a _ProductGeometry and the gradient is</span>
        <span class="c1"># stacked, split it</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span><span class="p">,</span> <span class="n">cuqi</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_ProductGeometry</span>
            <span class="p">)</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grad</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grad</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">grad</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span><span class="o">.</span><span class="n">stacked_par_split_indices</span><span class="p">)</span>

        <span class="c1"># If the domain geometry is not a _ProductGeometry, turn grad into a</span>
        <span class="c1"># list of length 1, so that we can iterate over it</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span><span class="p">,</span> <span class="n">cuqi</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_ProductGeometry</span><span class="p">):</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="p">[</span><span class="n">grad</span><span class="p">]</span>

        <span class="c1"># apply the gradient of each geometry component</span>
        <span class="n">grad_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v_par</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">kwargs_par</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">geometries</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;gradient&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">grad</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">grad_kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">geometries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">grad</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v_par</span><span class="p">)</span>
                <span class="c1"># update the ith component of grad_is_par to True</span>
                <span class="n">grad_is_par</span> <span class="o">=</span> <span class="n">grad_is_par</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="kc">True</span><span class="p">,)</span> <span class="o">+</span> <span class="n">grad_is_par</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">grad_kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">grad</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># convert the computed gradient to parameters</span>
        <span class="n">grad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_2par</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span><span class="p">,</span>
                          <span class="n">to_CUQIarray</span><span class="o">=</span><span class="n">to_CUQIarray</span><span class="p">,</span>
                          <span class="n">is_par</span><span class="o">=</span><span class="n">grad_is_par</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">grad_kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grad</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_dim</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_inputs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">pad</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="s2">&quot;CUQI </span><span class="si">{}</span><span class="s2">: &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;pad&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">pad</span>  
        <span class="k">return</span> <span class="s2">&quot;CUQI </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2"> -&gt; </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">    Forward parameters: </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">range_geometry</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_non_default_args</span><span class="p">)</span></div>


<div class="viewcode-block" id="AffineModel">
<a class="viewcode-back" href="../../../api/_autosummary/cuqi.model/cuqi.model.AffineModel.html#cuqi.model.AffineModel">[docs]</a>
<span class="k">class</span> <span class="nc">AffineModel</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Model class representing an affine model, i.e. a linear operator with a fixed shift. For linear models, represented by a linear operator only, see :class:`~cuqi.model.LinearModel`.</span>

<span class="sd">    The affine model is defined as:</span>

<span class="sd">    .. math::</span>

<span class="sd">        x \\mapsto Ax + shift</span>

<span class="sd">    where :math:`A` is the linear operator and :math:`shift` is the shift.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    linear_operator : 2d ndarray, callable function or cuqi.model.LinearModel</span>
<span class="sd">        The linear operator. If ndarray is given, the operator is assumed to be a matrix.</span>

<span class="sd">    shift : scalar or array_like</span>
<span class="sd">        The shift to be added to the forward operator.</span>

<span class="sd">    linear_operator_adjoint : callable function, optional</span>
<span class="sd">        The adjoint of the linear operator. Also used for computing gradients.</span>

<span class="sd">    range_geometry : cuqi.geometry.Geometry</span>
<span class="sd">        The geometry representing the range.</span>

<span class="sd">    domain_geometry : cuqi.geometry.Geometry</span>
<span class="sd">        The geometry representing the domain.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="AffineModel.__init__">
<a class="viewcode-back" href="../../../api/_autosummary/cuqi.model/cuqi.model.AffineModel.__init__.html#cuqi.model.AffineModel.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_operator</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">linear_operator_adjoint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">range_geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">domain_geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># If input represents a matrix, extract needed properties from it</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">linear_operator</span><span class="p">,</span> <span class="s1">&#39;__matmul__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">linear_operator</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">linear_operator_adjoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Adjoint of linear operator should not be provided when linear operator is a matrix. If you want to provide an adjoint, use a callable function for the linear operator.&quot;</span><span class="p">)</span>

            <span class="n">matrix</span> <span class="o">=</span> <span class="n">linear_operator</span>

            <span class="n">linear_operator</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">matrix</span><span class="nd">@x</span>
            <span class="n">linear_operator_adjoint</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">matrix</span><span class="o">.</span><span class="n">T</span><span class="nd">@y</span>

            <span class="k">if</span> <span class="n">range_geometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span>
                    <span class="n">range_geometry</span> <span class="o">=</span> <span class="n">_DefaultGeometry1D</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">LinearModel</span><span class="p">):</span>
                    <span class="n">range_geometry</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">range_geometry</span>

            <span class="k">if</span> <span class="n">domain_geometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span>
                    <span class="n">domain_geometry</span> <span class="o">=</span> <span class="n">_DefaultGeometry1D</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">LinearModel</span><span class="p">):</span>
                    <span class="n">domain_geometry</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">domain_geometry</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Ensure that the operators are a callable functions (either provided or created from matrix)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">linear_operator</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Linear operator must be defined as a matrix or a callable function of some kind&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">linear_operator_adjoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">linear_operator_adjoint</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Linear operator adjoint must be defined as a callable function of some kind&quot;</span><span class="p">)</span>

        <span class="c1"># If linear operator is of type Model, it needs to be a LinearModel</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linear_operator</span><span class="p">,</span> <span class="n">Model</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">linear_operator</span><span class="p">,</span> <span class="n">LinearModel</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;The linear operator should be a LinearModel object, a callable function or a matrix.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># If the adjoint operator is of type Model, it needs to be a LinearModel</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linear_operator_adjoint</span><span class="p">,</span> <span class="n">Model</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">linear_operator_adjoint</span><span class="p">,</span> <span class="n">LinearModel</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;The adjoint linear operator should be a LinearModel object, a callable function or a matrix.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Additional checks if the linear_operator is not a LinearModel:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linear_operator</span><span class="p">,</span> <span class="n">LinearModel</span><span class="p">):</span>
            <span class="c1"># Ensure the linear operator has exactly one input argument</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cuqi</span><span class="o">.</span><span class="n">utilities</span><span class="o">.</span><span class="n">get_non_default_args</span><span class="p">(</span><span class="n">linear_operator</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The linear operator should have exactly one input argument.&quot;</span>
                <span class="p">)</span>
            <span class="c1"># Ensure the adjoint linear operator has exactly one input argument</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">linear_operator_adjoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">cuqi</span><span class="o">.</span><span class="n">utilities</span><span class="o">.</span><span class="n">get_non_default_args</span><span class="p">(</span><span class="n">linear_operator_adjoint</span><span class="p">))</span>
                <span class="o">!=</span> <span class="mi">1</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The adjoint linear operator should have exactly one input argument.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Check size of shift and match against range_geometry</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">shift</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span> <span class="o">!=</span> <span class="n">range_geometry</span><span class="o">.</span><span class="n">par_dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The shift should have the same dimension as the range geometry.&quot;</span><span class="p">)</span>

        <span class="c1"># Store linear operator privately</span>
        <span class="c1"># Note: we need to set the _linear_operator before calling the</span>
        <span class="c1"># super().__init__() because it is needed when calling the property</span>
        <span class="c1"># _non_default_args within the super().__init__()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_linear_operator</span> <span class="o">=</span> <span class="n">linear_operator</span>

        <span class="c1"># Initialize Model class</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">linear_operator</span><span class="p">,</span> <span class="n">range_geometry</span><span class="p">,</span> <span class="n">domain_geometry</span><span class="p">)</span>

        <span class="c1"># Store matrix privately</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_matrix</span> <span class="o">=</span> <span class="n">matrix</span>

        <span class="c1"># Store shift as private attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shift</span> <span class="o">=</span> <span class="n">shift</span>


        <span class="c1"># Store adjoint function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_linear_operator_adjoint</span> <span class="o">=</span> <span class="n">linear_operator_adjoint</span>

        <span class="c1"># Define gradient</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gradient_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">direction</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">linear_operator_adjoint</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>

        <span class="c1"># Update forward function to include shift (overwriting the one from Model class)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_forward_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">linear_operator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">+</span> <span class="n">shift</span>

        <span class="c1"># Set stored_non_default_args to None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stored_non_default_args</span> <span class="o">=</span> <span class="kc">None</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_non_default_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stored_non_default_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Use arguments from user&#39;s callable linear operator</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stored_non_default_args</span> <span class="o">=</span> <span class="n">cuqi</span><span class="o">.</span><span class="n">utilities</span><span class="o">.</span><span class="n">get_non_default_args</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_linear_operator</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stored_non_default_args</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The shift of the affine model. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shift</span>

    <span class="nd">@shift</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Update the shift of the affine model. Updates both the shift value and the underlying forward function. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shift</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_forward_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linear_operator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">+</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_forward_func_no_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">is_par</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper function for computing the forward operator without the shift.&quot;&quot;&quot;</span>
        <span class="c1"># convert args to kwargs</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args_add_to_kwargs</span><span class="p">(</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">map_name</span><span class="o">=</span><span class="s2">&quot;model&quot;</span><span class="p">,</span> <span class="n">is_par</span><span class="o">=</span><span class="n">is_par</span>
        <span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="c1"># if model has _original_non_default_args, we use it to replace the</span>
        <span class="c1"># kwargs keys so that it matches self._linear_operator signature</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_original_non_default_args&#39;</span><span class="p">):</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_original_non_default_args</span><span class="p">,</span> <span class="n">args</span><span class="p">)}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_linear_operator</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">is_par</span><span class="o">=</span><span class="n">is_par</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_adjoint_func_no_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">is_par</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper function for computing the adjoint operator without the shift.&quot;&quot;&quot;</span>
        <span class="c1"># convert args to kwargs</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args_add_to_kwargs</span><span class="p">(</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="n">map_name</span><span class="o">=</span><span class="s1">&#39;adjoint&#39;</span><span class="p">,</span>
            <span class="n">is_par</span><span class="o">=</span><span class="n">is_par</span><span class="p">,</span>
            <span class="n">non_default_args</span><span class="o">=</span><span class="n">cuqi</span><span class="o">.</span><span class="n">utilities</span><span class="o">.</span><span class="n">get_non_default_args</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_linear_operator_adjoint</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_func</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_linear_operator_adjoint</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">is_par</span><span class="o">=</span><span class="n">is_par</span><span class="p">,</span> <span class="n">fwd</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="LinearModel">
<a class="viewcode-back" href="../../../api/_autosummary/cuqi.model/cuqi.model.LinearModel.html#cuqi.model.LinearModel">[docs]</a>
<span class="k">class</span> <span class="nc">LinearModel</span><span class="p">(</span><span class="n">AffineModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Model based on a Linear forward operator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    forward : 2D ndarray or callable function.</span>
<span class="sd">        Forward operator.</span>

<span class="sd">    adjoint : 2D ndarray or callable function. (optional if matrix is passed as forward)</span>

<span class="sd">    range_geometry : integer or cuqi.geometry.Geometry (optional)</span>
<span class="sd">        If integer is given, a cuqi.geometry._DefaultGeometry is created with dimension of the integer.</span>

<span class="sd">    domain_geometry : integer or cuqi.geometry.Geometry (optional)</span>
<span class="sd">        If integer is given, a cuqi.geometry._DefaultGeometry is created with dimension of the integer.</span>


<span class="sd">    :ivar range_geometry: The geometry representing the range.</span>
<span class="sd">    :ivar domain_geometry: The geometry representing the domain.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>

<span class="sd">    Consider a linear model represented by a matrix, i.e., :math:`y=Ax` where </span>
<span class="sd">    :math:`A` is a matrix.</span>
<span class="sd">    </span>
<span class="sd">    We can define such a linear model by passing the matrix :math:`A`:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import numpy as np</span>
<span class="sd">        from cuqi.model import LinearModel</span>

<span class="sd">        A = np.random.randn(2,3)</span>

<span class="sd">        model = LinearModel(A)</span>

<span class="sd">    The dimension of the range and domain geometries will be automatically </span>
<span class="sd">    inferred from the matrix :math:`A`.</span>
<span class="sd">        </span>
<span class="sd">    Meanwhile, such a linear model can also be defined by a forward function </span>
<span class="sd">    and an adjoint function:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import numpy as np</span>
<span class="sd">        from cuqi.model import LinearModel</span>

<span class="sd">        A = np.random.randn(2,3)</span>

<span class="sd">        def forward(x):</span>
<span class="sd">            return A@x</span>

<span class="sd">        def adjoint(y):</span>
<span class="sd">            return A.T@y</span>

<span class="sd">        model = LinearModel(forward,</span>
<span class="sd">                            adjoint=adjoint,</span>
<span class="sd">                            range_geometry=2,</span>
<span class="sd">                            domain_geometry=3)</span>

<span class="sd">    Note that you would need to specify the range and domain geometries in this</span>
<span class="sd">    case as they cannot be inferred from the forward and adjoint functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LinearModel.__init__">
<a class="viewcode-back" href="../../../api/_autosummary/cuqi.model/cuqi.model.LinearModel.__init__.html#cuqi.model.LinearModel.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="n">adjoint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">range_geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">domain_geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># Initialize as AffineModel with shift=0</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">forward</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">adjoint</span><span class="p">,</span> <span class="n">range_geometry</span><span class="p">,</span> <span class="n">domain_geometry</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearModel.adjoint">
<a class="viewcode-back" href="../../../api/_autosummary/cuqi.model/cuqi.model.LinearModel.adjoint.html#cuqi.model.LinearModel.adjoint">[docs]</a>
    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">is_par</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Adjoint of the model.</span>
<span class="sd">        </span>
<span class="sd">        Adjoint converts the input to function values (if needed) using the range geometry of the model then applies the adjoint operator to the function values and converts the output function values to parameters using the domain geometry of the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args : ndarrays or cuqi.array.CUQIarray object</span>
<span class="sd">            Positional arguments for the adjoint operator ( maximum one argument). The adjoint operator input can be specified as either positional arguments or keyword arguments but not both.</span>

<span class="sd">        **kwargs : keyword arguments</span>
<span class="sd">            keyword arguments for the adjoint operator (maximum one argument). The adjoint operator input can be specified as either positional arguments or keyword arguments but not both.</span>

<span class="sd">            If the input is specified as keyword arguments, the keys should match the non_default_args of the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray or cuqi.array.CUQIarray</span>
<span class="sd">            The adjoint model output. Always returned as parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args_add_to_kwargs</span><span class="p">(</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="n">map_name</span><span class="o">=</span><span class="s1">&#39;adjoint&#39;</span><span class="p">,</span>
            <span class="n">is_par</span><span class="o">=</span><span class="n">is_par</span><span class="p">,</span>
            <span class="n">non_default_args</span><span class="o">=</span><span class="n">cuqi</span><span class="o">.</span><span class="n">utilities</span><span class="o">.</span><span class="n">get_non_default_args</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_linear_operator_adjoint</span>
            <span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># length of kwargs should be 1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The adjoint operator input is specified by more than one argument. This is not supported.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linear_operator_adjoint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No adjoint operator was provided for this model.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_func</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_linear_operator_adjoint</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">is_par</span><span class="o">=</span><span class="n">is_par</span><span class="p">,</span> <span class="n">fwd</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__matmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="LinearModel.get_matrix">
<a class="viewcode-back" href="../../../api/_autosummary/cuqi.model/cuqi.model.LinearModel.get_matrix.html#cuqi.model.LinearModel.get_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an ndarray with the matrix representing the forward operator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1">#Matrix exists so return it</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matrix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO: Can we compute this faster while still in sparse format?</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">csc_matrix</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">range_dim</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="c1">#Sparse (m x 1 matrix)</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain_dim</span><span class="p">)</span>

            <span class="c1"># Stacks sparse matrices on csc matrix</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain_dim</span><span class="p">):</span>
                <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">col_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">hstack</span><span class="p">((</span><span class="n">mat</span><span class="p">,</span><span class="n">col_vec</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]))</span> <span class="c1">#mat[:,i] = self.forward(e)</span>
                <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Store matrix for future use</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_matrix</span> <span class="o">=</span> <span class="n">mat</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matrix</span>   </div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transpose of linear model. Returns a new linear model acting as the transpose.&quot;&quot;&quot;</span>
        <span class="n">transpose</span> <span class="o">=</span> <span class="n">LinearModel</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_linear_operator_adjoint</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_linear_operator</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">domain_geometry</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">range_geometry</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">transpose</span><span class="o">.</span><span class="n">_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matrix</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">transpose</span></div>



<div class="viewcode-block" id="PDEModel">
<a class="viewcode-back" href="../../../api/_autosummary/cuqi.model/cuqi.model.PDEModel.html#cuqi.model.PDEModel">[docs]</a>
<span class="k">class</span> <span class="nc">PDEModel</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Model based on an underlying cuqi.pde.PDE.</span>
<span class="sd">    In the forward method the PDE is assembled, solved and observed.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    PDE : cuqi.pde.PDE</span>
<span class="sd">        The PDE that specifies the forward operator.</span>

<span class="sd">    range_geometry : integer or cuqi.geometry.Geometry, optional</span>
<span class="sd">        If integer is given, a cuqi.geometry._DefaultGeometry is created with dimension of the integer.</span>

<span class="sd">    domain_geometry : integer or cuqi.geometry.Geometry, optional</span>
<span class="sd">        If integer is given, a cuqi.geometry._DefaultGeometry is created with dimension of the integer.</span>


<span class="sd">    :ivar range_geometry: The geometry representing the range.</span>
<span class="sd">    :ivar domain_geometry: The geometry representing the domain.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="PDEModel.__init__">
<a class="viewcode-back" href="../../../api/_autosummary/cuqi.model/cuqi.model.PDEModel.__init__.html#cuqi.model.PDEModel.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">PDE</span><span class="p">:</span> <span class="n">cuqi</span><span class="o">.</span><span class="n">pde</span><span class="o">.</span><span class="n">PDE</span><span class="p">,</span> <span class="n">range_geometry</span><span class="p">,</span> <span class="n">domain_geometry</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">PDE</span><span class="p">,</span> <span class="n">cuqi</span><span class="o">.</span><span class="n">pde</span><span class="o">.</span><span class="n">PDE</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;PDE needs to be a cuqi PDE.&quot;</span><span class="p">)</span>
        <span class="c1"># PDE needs to be set before calling super().__init__</span>
        <span class="c1"># for the property _non_default_args to work</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pde</span> <span class="o">=</span> <span class="n">PDE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stored_non_default_args</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># If gradient or jacobian is not provided, we create it from the PDE</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;gradient&quot;</span><span class="p">,</span> <span class="s2">&quot;jacobian&quot;</span><span class="p">]]):</span>
            <span class="c1"># Create gradient or jacobian function to pass to the Model based on</span>
            <span class="c1"># the PDE object. The dictionary derivative_kwarg contains the</span>
            <span class="c1"># created function along with the function type (either &quot;gradient&quot;</span>
            <span class="c1"># or &quot;jacobian&quot;)</span>
            <span class="n">derivative_kwarg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_derivative_function</span><span class="p">()</span>
            <span class="c1"># append derivative_kwarg to kwargs</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">derivative_kwarg</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">forward</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_forward_func_pde</span><span class="p">,</span>
                         <span class="n">range_geometry</span><span class="o">=</span><span class="n">range_geometry</span><span class="p">,</span>
                         <span class="n">domain_geometry</span><span class="o">=</span><span class="n">domain_geometry</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_non_default_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stored_non_default_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># extract the non-default arguments of the PDE</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stored_non_default_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pde</span><span class="o">.</span><span class="n">_non_default_args</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stored_non_default_args</span>

    <span class="k">def</span> <span class="nf">_forward_func_pde</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pde</span><span class="o">.</span><span class="n">assemble</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">sol</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pde</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

        <span class="n">obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pde</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">obs</span>

    <span class="k">def</span> <span class="nf">_create_derivative_function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Private function that creates the derivative function (gradient or</span>
<span class="sd">        jacobian) based on the PDE object. The derivative function is created as</span>
<span class="sd">        a lambda function that takes the direction and the parameters as input </span>
<span class="sd">        and returns the gradient or jacobian of the PDE. This private function</span>
<span class="sd">        returns a dictionary with the created function and the function type</span>
<span class="sd">        (either &quot;gradient&quot; or &quot;jacobian&quot;).&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pde</span><span class="p">,</span> <span class="s2">&quot;gradient_wrt_parameter&quot;</span><span class="p">):</span>
            <span class="c1"># Build the string that will be used to create the lambda function</span>
            <span class="n">function_str</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;lambda direction, &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_non_default_args</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;, pde_func: pde_func(direction, &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_non_default_args</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
            <span class="p">)</span>

            <span class="c1"># create the lambda function from the string</span>
            <span class="n">function</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">function_str</span><span class="p">)</span>

            <span class="c1"># create partial function from the lambda function with gradient_wrt_parameter</span>
            <span class="c1"># as the first argument</span>
            <span class="n">grad_func</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">pde_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pde</span><span class="o">.</span><span class="n">gradient_wrt_parameter</span><span class="p">)</span>

            <span class="c1"># Return the gradient function</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;gradient&quot;</span><span class="p">:</span> <span class="n">grad_func</span><span class="p">}</span>

        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pde</span><span class="p">,</span> <span class="s2">&quot;jacobian_wrt_parameter&quot;</span><span class="p">):</span>
            <span class="c1"># Build the string that will be used to create the lambda function</span>
            <span class="n">function_str</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;lambda &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_non_default_args</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;, pde_func: pde_func( &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_non_default_args</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
            <span class="p">)</span>

            <span class="c1"># create the lambda function from the string</span>
            <span class="n">function</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">function_str</span><span class="p">)</span>

            <span class="c1"># create partial function from the lambda function with jacobian_wrt_parameter</span>
            <span class="c1"># as the first argument</span>
            <span class="n">jacobian_func</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">pde_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pde</span><span class="o">.</span><span class="n">jacobian_wrt_parameter</span><span class="p">)</span>

            <span class="c1"># Return the jacobian function</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;jacobian&quot;</span><span class="p">:</span> <span class="n">jacobian_func</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span> <span class="c1"># empty dictionary if no gradient or jacobian is found</span>

    <span class="c1"># Add the underlying PDE class name to the repr.</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    PDE: </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pde</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span></div>

</pre></div>

                </article>
              
              
              
              
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
       Copyright 2022, CUQI Project, Technical University of Denmark (DTU).
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 9.1.0.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>